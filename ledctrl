#!/usr/bin/env python3
#
# ledctrl
#
# min python version: 3.5
#
# dependencies:
#  - python-systemd
#
# © 2016 Björn Busse (see also: LICENSE)
# bj.rn@baerlin.eu

import logging
import math
import os
import random
import socket
import subprocess
import signal
import struct
import sys
import termios
import time
import configargparse
from systemd import journal
from homekit import AccessoryServer
from homekit.model import Accessory, LightBulbService


f2c = lambda f: int(f * 255.0) & 0xff
c2f = lambda c: float(c) / 255.0
alpha = lambda c: (c >> 24) & 0xff
red = lambda c: (c >> 16) & 0xff
green = lambda c: (c >> 8) & 0xff
blue = lambda c: c & 0xff
pack = lambda a, r, g, b: (f2c(a) << 24) | (f2c(r) << 16) | (f2c(g) << 8) | f2c(b)


class Server():

    def __init__(self,
                 server_proto,
                 server_ip,
                 server_port,
                 client_ip,
                 client_port,
                 dim_x,
                 dim_y):

        self.s_ip = server_ip
        self.s_port = server_port
        self.client_con = UDPClient(client_ip, client_port)
        self.server_proto = server_proto
        self.serve()

        HandleSignals()

        self.matrix = Matrix(self.sock, dim_x, dim_y, self.client_con)
        self.matrix.reset()
        self.state = False
        self.payload = ""

    def toggle_state(self):
        '''
        Toggle on/off state
        '''
        self.state = not self.state

    def get_toggle_state(self):
        return self.state

    def set_payload(self, payload):
        self.payload = payload

    def get_payload(self):
        return self.payload

    def serve(self):
        self.sock = socket.socket(socket.AF_INET,
                                  socket.SOCK_DGRAM)

        try:
            self.sock.bind((self.s_ip, self.s_port))
        except OSError as e:
            log.error("Failed to bind socket: %s %d %s", self.s_ip, self.s_port, e)
            sys.exit(1)

        log.info("Serving on %s %s", self.s_ip, self.s_port)

    def receive(self):
        data = ""

        # non-blocking (0x40)
        try:
            data, (ip, port) = self.sock.recvfrom(1024, 0x40)
            log.debug("UDP: Received data on %s:%d", ip, port)
        except:
            log.debug("UDP: No data received")

        if len(data) > 0:
            self.parse_msg(data)

    def get_port(self):
        return self.s_port

    def parse_msg(self, data):
        data = str(data).strip('b\'')
        msg = "Received message: " + data
        log.info(msg)

        if data == "ping":
            log.info("pong")
            return

        if data == "get-payload":
            log.info("Current payload: %s", self.get_payload())
            return

        self.matrix.exec_payload(data)


class Matrix(Server):

    reverse_even_row = False
    status = "Reverse Pixel Order"
    frame_prev = []

    _px_layout = [0, 1, 2, 3, 4,
                  9, 8, 7, 6, 5,
                 10, 11, 12, 13, 14,
                 19, 18, 17, 16, 15,
                 20, 21, 22, 23, 24]

    px_layout = [  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
                  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
                  20,  21,  22,  23 , 24,  25,  26,  27,  28,  29,
                  30,  31,  63,  62,  61,  60,  59,  58,  57,  56,
                  55,  54,  53,  52,  51,  50,  49,  48,  47 , 46,
                  45,  44,  43,  42,  41,  40,  39,  38,  37,  36,
                  35,  34,  33,  32,  64,  65,  66,  67,  68,  69,
                  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
                  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
                  90,  91,  92,  93,  94,  95, 127, 126, 125, 124,
                 123, 122, 121, 120, 119, 118, 117, 116, 115, 114,
                 113, 112, 111, 110, 109, 108, 107, 106, 105, 104,
                 103, 102, 101, 100,  99,  98,  97,  96, 128, 129,
                 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
                 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
                 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
                 191, 190, 189, 188, 187, 186, 185, 184, 183, 182,
                 181, 180, 179, 178, 177, 176, 175, 174, 173, 172,
                 171, 170, 169, 168, 167, 166, 165, 164, 163, 162,
                 161, 160, 192, 193, 194, 195, 196, 197, 198, 199,
                 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
                 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
                 220, 221, 222, 223, 255, 254, 253, 252, 251, 250,
                 249, 248, 247, 246, 245, 244, 243, 242, 241, 240,
                 239, 238, 237, 236, 235, 234, 233, 232, 231, 230,
                 229, 228, 227, 226, 225, 224]

    def __init__(self, sock, dim_x, dim_y, con):
        self.con = con
        self.dim_x = dim_x
        self.dim_y = dim_y
        self.npxm = dim_x * dim_y
        self.sock = sock
        self.state = False
        self.current_colour = "000000"

    def get_payload(self):
        return self.state

    def exec_payload(self, data):
        exec_args = data.split()
        print(*exec_args, sep='\t')
        payload = exec_args.pop(0)
        self.set_payload(payload)

        log.info("Executing payload: %s", payload)

        if payload == "turn-on":
            colour = "FF3399"
            self.set_colour(colour)
            return True

        if payload == "turn-off":
            colour = "000000"
            self.set_colour(colour)
            return True

        if payload == "toggle":
            state = self.get_toggle_state()
            log.info("State: %s", str(state))
            if not state:
                colour = "FF3399"
                self.toggle_state()
                self.set_colour(colour)
            else:
                colour = "000000"
                self.toggle_state()
                self.set_colour(colour)
            return True

        if payload == "cycle":
            colour = "FF3399"
            colour_bg = "000000"
            self.cycle(colour, colour_bg, 0.1, 32)
            return True

        if payload in ['set-colour', 'switch-colour']:
            colour = "99FF66"
            if len(exec_args) == 1:
                if len(exec_args[0]) == 6:
                    colour = exec_args[0]
                    self.set_colour(colour, "000000", 23, 0)
            elif len(exec_args) == 2:
                if len(exec_args[0]) == 6:
                    colour = exec_args[0]
                    npx = int(exec_args[1])
                    if npx > -1 <= self.npxm:
                        self.set_colour(colour, "000000", npx, 0)
            elif len(exec_args) == 3:
                if len(exec_args[0]) == 6:
                    colour = exec_args[0]
                    npx = int(exec_args[1])
                    offset = int(exec_args[2])
                    if npx > -1 <= self.npxm:
                        self.set_colour(colour, "000000", npx, offset)
            return True

        if payload == "set-random-colour":
            self.set_random_colour(True, 1, 10)
            return True

        if payload == "fade-colours":
            self.colour_fade()
            return True

        if payload == "show-snake":
            self.show_rainbow_snake()
            return True

        if payload == "show-rainbow":
            self.show_rainbow()
            return True

        if payload == "set-random-pixel":
            self.set_random_pixel()
            return True

        if payload == "show-text":
            if len(exec_args) == 1:
                text = exec_args[0]
                self.show_text(text)
            return True

        if payload == "show-image":
            self.show_image("e.bmp")
            return True

        if payload == "show-clock":
            self.show_clock()
            return True

        if payload == "play-snake":
            SnakeGame(self.client_con, self.matrix)
            return True

        if payload == "cycle-lines":
            colour = "FF3399"
            colour_bg = "000000"
            self.move_lines(colour, colour_bg, 0.08)
            return True

        log.info("There is no such command or payload")
        show_help()
        return False


    def get_px_pos(self, pixel):
        return self.px_layout.index(pixel)

    @staticmethod
    def colour_complementary(colour):
        complementary_colour = 0xFFFFFF ^ int(colour, 16)
        return complementary_colour

    @staticmethod
    def colour_gen_hex_code():
        return ''.join([random.choice('0123456789ABCDEF') for x in range(6)])

    @staticmethod
    def colour_hex_to_rgb(hex_str):
        if hex_str.startswith('#'):
            hex_str = hex[1:]
        if hex_str.__len__() == 3:
            hex_str = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]
        return tuple([int(hex_str[i:i + 2], 16) for i in range(0, len(hex_str), 2)])

    @staticmethod
    def colour_rgb_to_hex(rgb):
        return ''.join(["%0.2X" % c for c in rgb])

    def colour_hex_to_hls(self, c_hex):
        rgb = self.colour_hex_to_rgb(c_hex)
        return rgb_to_hls(rgb[0], rgb[1], rgb[2])

    def colour_fade(self, colours=[0xffFFF5C3, 0xff0BD7D5, 0xffFF7260], speed=1, steps=1000):

        for x in range(colours.__len__()):
            if isinstance(colours[x], int):
                c = "0xff" + str(colours[x])
                colours[x] = int(c, 16)

        colours = self.colour_get_gradient(colours, steps)
        log.info(str(colours.__len__()))

        while True:
            for x in range(colours.__len__()):
                self.set_colour(colours[x])
                time.sleep(speed)

            # Reverse list
            colours = colours[::-1]

    @staticmethod
    def colour_get_gradient(colours, steps):
        colours_per_step = steps / len(colours)
        gradient = []

        for x, colour in enumerate(colours):

            r1 = c2f(red(colour))
            g1 = c2f(green(colour))
            b1 = c2f(blue(colour))

            colour2 = colours[(x + 1) % len(colours)]

            r2 = c2f(red(colour2))
            g2 = c2f(green(colour2))
            b2 = c2f(blue(colour2))

            # Generate a gradient of one step from colour to colour:
            delta = 1.0 / colours_per_step
            for y in range(int(colours_per_step)):
                t = y * delta
                a = 1.0
                r = (1.0 - t) * r1 + t * r2
                g = (1.0 - t) * g1 + t * g2
                b = (1.0 - t) * b1 + t * b2

                c = '0x{0:x}'.format(pack(a, r, g, b))
                gradient.append(c[4:])

        return gradient

    def reset(self, colour="794044"):
        self.set_colour(colour)

    def set_colour(self, colour="FFFFFF",
                         colour_bg="000000",
                         npx=0,
                         offset=0):

        frame = []
        self.current_colour = colour
        c_complement = self.colour_complementary(colour)
        rgb = self.colour_hex_to_rgb(colour)
        log.info("Setting %d Pixel(s), starting at %d", npx, offset)
        log.info("\x1b[38;%d;%d;%d;249m%s\x1b[0m %s (%d,%d,%d)", rgb[0],
                                                                 rgb[1],
                                                                 rgb[2],
                                                                 colour,
                                                                 colour,
                                                                 rgb[0],
                                                                 rgb[1],
                                                                 rgb[2])

        if npx > 0:
            # Set selected pixels to colour
            for x in range(self.npxm):
                if x >= offset and x < npx:
                    frame.append(colour)
                else:
                    frame.append(colour_bg)
        else:
            # Set all pixels to colour
            for x in range(self.npxm):
                frame.append(colour)

        self.draw(frame)

    def set_random_colour(self, t_sleep, fade=False, fade_speed=1, fade_cycles=10):

        while True:
            colour = self.colour_gen_hex_code()
            if fade:
                colour_0 = int("0xff" + self.current_colour, 16)
                colour_1 = int("0xff" + colour, 16)
                self.colour_fade([colour_0, colour_1], fade_speed, fade_cycles)
            else:
                self.set_colour(colour)
            time.sleep(t_sleep)

    def set_random_pixel(self, t_sleep=0.5):

        while True:
            frame = []

            log.info("state: " + self.state + " payload: " + self.payload)
            if self.state != "switch":
                return

            for _ in range(self.npxm):
                frame.append(self.colour_gen_hex_code())

            self.draw(frame)
            time.sleep(t_sleep)
            self.reset()

    def show_image(self, filename):
        img = Bitmap(filename, self.dim_x, self.dim_y)
        img_data = img.read_file(filename)
        img.print_header_data(filename)
        bmp_frame = img.read_pixel_array(filename)
        log.debug(bmp_frame)

    def cycle(self, colour, colour_bg, speed=0.1, npx=1):
        while True:
            for i in range(self.npxm):
                if self.state != payload:
                    return

                if npx > -1:
                    # Set npx pixels at once
                    self.set_colour(colour, colour_bg, npx, i)
                else:
                    # Set a single pixel
                    self.set_colour(colour, colour_bg, 1, 1)

                log.info("state: " + self.state + " payload: " + self.payload)
                time.sleep(speed)

    @staticmethod
    def shift(list_, nshift):
        for _ in range(nshift):
            t = list.pop()
            list_.insert(0, t)

        return list_

    def show_rainbow(self, colours = ["ffa500",
                                      "ff4500",
                                      "8a2be2",
                                      "0000ff",
                                      "7fffd4",
                                      "228b22",
                                      "ffff00"],
                                      speed=0.1):

        while True:
            frame = []

            for y in range(self.dim_y):
                for _ in range(self.dim_x):
                    frame.append(colours[y])

            self.draw(frame)
            colours = self.shift(colours, 1)
            time.sleep(speed)

    def show_rainbow_snake(self, colours = ["ffa500",
                                            "ff4500",
                                            "8a2be2",
                                            "0000ff",
                                            "7fffd4",
                                            "228b22",
                                            "ffff00"],
                                            c_bg="444444",
                                            speed=1):

        frame = []

        for x in range(colours.__len__()):
            frame.append(colours[x])

        if self.npxm > colours.__len__():
            for x in range(colours.__len__(), self.npxm):
                frame.append(c_bg)

        while True:
            self.reverse_even_row = False
            self.draw(frame)
            frame = self.shift(frame, 1)
            time.sleep(speed)

    def show_clock(self, c_h="ff0000", c_m="ff0000", c_bg="ffffff"):

        while True:
            frame = []
            t_h = int(time.strftime("%H"))
            t_m = time.strftime("%M")
            t_m1 = int(t_m[0:1])
            t_m2 = int(t_m[1:2])

            for x in range(0, self.npxm):
                if x < t_h:
                    frame.append(c_h)
                else:
                    frame.append(c_bg)

            self.draw(frame)
            time.sleep(3)
            frame = []

            for x in range(0, self.npxm):

                if x < 15 and x < t_m1:
                    frame.append(c_m)
                elif x > 14 < (t_m2 + 15):
                    frame.append(c_m)
                else:
                    frame.append(c_bg)

            self.draw(frame)
            time.sleep(5)

    # reverse_direction: Do not jump to line 1 but go backwards
    # on last line
    def move_lines(self, colour, colour_bg, speed, reverse_direction=True):
        '''
        Draw lines of variable length at some offset
        :param str colour: The colour of the line
        :param str colour_bg: The background colour
        :param float speed: The refresh rate
        :param bool reverse_direction: Reverse moving direction, defaults to True
        '''
        up = True

        while True:
            for i in range(1, self.dim_y + 1):

                # Move into one direction
                if up:
                    j = i
                    if i == 6 and reverse_direction:
                        up = not up
                # Reverse direction
                else:
                    j = self.dim_y - i
                    if j == 1:
                        i = 2
                        up = not up
                        break

                offset = (j * self.dim_x) - self.dim_x
                log.debug("%d %d %d", j, self.dim_x, offset)
                self.set_colour(colour, colour_bg, self.dim_x, offset)
                time.sleep(speed)

    def px_get_row(self, pixel):
        return math.ceil((pixel + 1) / self.matrix.dim_y)

    def px_get_column(self, pixel):
        nrow = self.px_get_row(pixel)
        if nrow == 0:
            ncol = pixel - self.matrix.dim_x
        else:
            ncol = pixel - (self.matrix.dim_x * nrow) + self.matrix.dim_x + 1
        return ncol

    def scroll_text(self, text, speed=0.5, c_fg="ff0000", c_bg="ffffff", direction="left"):
        nframes = text.__len__() * self.npxm
        start = 0
        t=[]

        for y in range(text.__len__()):
            t.append(text[y])

        for _ in range(0, nframes):
            frame = []

            if direction == "left":
                z = 0
                l = t.__len__() - 5
                for y in range(l):
                    if y == z:
                        z = z + 5
                        p = t.pop(y)
                        log.debug("Popped %d", y)
                        if y >= self.npxm:
                            i = y - self.npxm
                            log.debug("Inserting %d %d", i, p)
                            t.insert(i, p)

                for y in range(self.npxm):
                    c = c_bg
                    if y < len(t):
                        if t[y] == "1":
                            c = c_fg
                    frame.append(c)

                self.draw(frame)


            if direction == "up":
                for y in range(self.npxm):
                    if text[start+y]:
                        c = c_bg
                    else:
                        c = c_fg

                    frame.append(c)

                start = start + self.dim_x

            self.draw(frame)
            time.sleep(speed)

    def show_text(self, string, scroll=True, loop=True, speed=1):
        t_sleep = speed
        text = ""

        if scroll:
            for x in range(string.__len__()):
                text += str(self.font_get_char(string[x]))
            self.scroll_text(text, speed)

        else:
            if loop:
                while True:
                    for x in range(string.__len__()):
                        self.font_show_char(string[x])
                        time.sleep(t_sleep)

            for x in range(string.__len__()):
                self.font_show_char(string[x])
                time.sleep(t_sleep)

    @staticmethod
    def font_get_char(char):
        f5x5 = {"A" : "0010001010011100101001010",
                "B" : "1111010001111101000111110",
                "C" : "0111110000100001000001111",
                "D" : "1111010001100011000111110",
                "E" : "1111110000111111000011111",
                "F" : "1111110000111001000010000",
                "G" : "0111110000101111000101111",
                "H" : "1000110001111111000110001",
                "I" : "0010000100001000010000100",
                "J" : "0011100001000011000101110",
                "K" : "1001010100111101000110001",
                "L" : "0100001000010000100001110",
                "N" : "1100110101101011010110011",
                "T" : "1111100100001000010000100",
                "i" : "0010000000001000010000100",
                "3" : "0111000001011100000101110",
                " " : "0000000000000000000000000",
                "<" : "0001000100010000010000010",
                ":" : "0000000100000000010000000"}

        return f5x5[char]

    def font_show_char(self, char, c_fg="FF0000", c_bg="FFFFFF"):
        frame = []
        p = self.font_get_char(char)

        for x in range(p.__len__()):
            px = p[x]

            if px == "0":
                px = c_bg
            else:
                px = c_fg

            frame.append(px)

        self.draw(frame)

    def draw(self, frame):
        msg = ""

        if self.reverse_even_row:
            for x in range(0, self.npxm):
                msg += frame[self.px_layout.index(x)]
        else:
            for x in range(0, self.npxm):
                msg += frame[x]


        self.con.send(msg)
        super().receive()


class Bitmap():

    def __init__(self, filename, x, y):
        self.dim_x = x
        self.dim_y = y
        self.height = self.get_height(filename)
        self.width = self.get_width(filename)

    @staticmethod
    def colour_rgb_to_hex(rgb):
        return ''.join(["%0.2X" % c for c in rgb])

    @staticmethod
    def read_file(filename):
        file = open(filename, "rb")
        data = file.read()
        file.close()
        return data

    @staticmethod
    def get_header_size(filename):
        offset = 10
        fh = open(filename, 'rb')
        fh.seek(offset, 0)
        pixel_array_offset = struct.unpack('I', fh.read(4))
        return pixel_array_offset[0]

    @staticmethod
    def get_height(filename):
        offset = 10
        fh = open(filename, 'rb')
        fh.seek(offset, 0)
        width = struct.unpack('I', fh.read(4))
        return width[0]

    @staticmethod
    def get_width(filename):
        return 24

    def read_pixel_array(self, filename):
        fh = open(filename, "rb")

        # Skip the DIB header (12-124)
        header_size = self.get_header_size(filename)
        fh.seek(header_size, 0)

        # Pixels are stored starting at the bottom left
        frame = []
        rows = []
        row = []
        npx = 0

        while True:
            if npx == self.width:
                npx = 0
                rows.insert(0, row)
                if len(row) != self.width * 3:
                    raise Exception("Unsupported row length")
                row = []
            npx += 1

            r_str = fh.read(1)
            g_str = fh.read(1)
            b_str = fh.read(1)

            if len(r_str) == 0:
                # This is expected to happen when we've read everything.
                if len(rows) != self.dim_y:
                    log.error("Failed to parse pixel array of bitmap")
                break

            if len(g_str) == 0:
                log.error("Got 0 length string for green. Aborting")
                break

            if len(b_str) == 0:
                log.error("Got 0 length string for blue. Aborting")
                break

            r = ord(r_str)
            g = ord(g_str)
            b = ord(b_str)
            row.append(b)
            row.append(g)
            row.append(r)
            rgb = (r, g, b)

            frame.append(self.colour_rgb_to_hex(rgb))

        fh.close()
        return frame

    @staticmethod
    def print_header_data(filename):
        bmp = open(filename, 'rb')
        print('Type:', bmp.read(2).decode())
        print('Size: %s' % struct.unpack('I', bmp.read(4)))
        print('Reserved 1: %s' % struct.unpack('H', bmp.read(2)))
        print('Reserved 2: %s' % struct.unpack('H', bmp.read(2)))
        print('Offset: %s' % struct.unpack('I', bmp.read(4)))
        print('DIB Header Size: %s' % struct.unpack('I', bmp.read(4)))
        print('Width: %s' % struct.unpack('I', bmp.read(4)))
        print('Height: %s' % struct.unpack('I', bmp.read(4)))
        print('Colour Planes: %s' % struct.unpack('H', bmp.read(2)))
        print('Bits per Pixel: %s' % struct.unpack('H', bmp.read(2)))
        print('Compression Method: %s' % struct.unpack('I', bmp.read(4)))
        print('Raw Image Size: %s' % struct.unpack('I', bmp.read(4)))
        print('Horizontal Resolution: %s' % struct.unpack('I', bmp.read(4)))
        print('Vertical Resolution: %s' % struct.unpack('I', bmp.read(4)))
        print('Number of Colours: %s' % struct.unpack('I', bmp.read(4)))
        print('Important Colours: %s' % struct.unpack('I', bmp.read(4)))


class UDPClient():

    def __init__(self, c_ip, c_port):
        self.client_ip = c_ip
        self.client_port = c_port
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        #self.sock.setsockopt(socket.IPPROTO_IP, IN.IP_MTU_DISCOVER, IN.IP_PMTUDISC_WANT)
        self.sock.setsockopt(socket.IPPROTO_IP, socket.SO_REUSEADDR, 1)
        #self.sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)

    def send(self, msg):
        try:
            self.sock.sendto(bytes.fromhex(msg), (self.client_ip, self.client_port))
        except Exception as e:
            log.info(str(e))
            log.info("Network unavailable. Aborting")
            sys.exit(1)

    def sendm(self, msg):
        try:
            self.sock.sendto(bytes(msg, "UTF-8"), (self.client_ip, self.client_port))
        except:
            log.info("Network unavailable. Aborting")
            sys.exit(1)


class KeyInput():

    old_settings = None

    def __init__(self):
        self.key_set = []
        self.old_settings = termios.tcgetattr(sys.stdin)

        new_settings = termios.tcgetattr(sys.stdin)
        new_settings[3] = new_settings[3] & ~(termios.ECHO | termios.ICANON)
        new_settings[6][termios.VMIN] = 0
        new_settings[6][termios.VTIME] = 0
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, new_settings)
        self.key = ""

    def get_key(self):
        self.key = os.read(sys.stdin.fileno(), 3)

        if self.key is not None and len(self.key) > 0:
            self.key_set.append(self.key)

        return self.key

    def get_key_parsed(self):
        self.key = self.get_key()

        if self.key  == bytes('\x1b[A', "utf-8"):
            return "up"
        if self.key == bytes('\x1b[B', "utf-8"):
            return "down"
        if self.key == bytes('\x1b[C', "utf-8"):
            return "right"
        if self.key == bytes('\x1b[D', "utf-8"):
            return "left"

        return False

    #@atexit.register
    def exit(self):
        if self.old_settings:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_settings)


class SnakeGame():

    px_snake = []
    px_food = []
    px_snake_head = 0
    frame = []
    frame_prev = []

    def __init__(self, con, matrix, c_fg="ff0000", c_food="0000ff", c_bg="ffffff"):
        self.con = con
        self.matrix = matrix
        npxm = self.set_start_px()
        self.c_fg = c_fg
        self.c_bg = c_bg
        self.c_food = c_food
        self.keyboard = KeyInput()
        self.matrix.draw(self.get_frame())
        dirs = ["up", "down", "left", "right"]
        direction = random.choice(dirs)
        self.start_game(direction)

    def start_game(self, direction):

        cycles = 0

        while True:

            key = self.keyboard.get_key_parsed()

            if key is not None and len(key) > 0:

                if key  == 'up':
                    direction = "up"
                elif key == 'down':
                    direction = "down"
                elif key == 'right':
                    direction = "right"
                elif key == 'left':
                    direction = "left"

            time.sleep(0.1)
            cycles = cycles + 1

            if cycles > 10:

                self.move(direction)
                self.matrix.draw(self.get_frame())

                if not self.px_food:
                    self.set_food()

                cycles = 0


    def set_start_px(self):
        px = random.randint(0, self.matrix.npxm - 1)
        self.px_snake.append(px)
        self.px_snake_head = px
        return px

    def move(self, direction):
        px = 0
        #ncol = self.matrix.px_get_column(self.px_snake_head)
        #nrow = self.matrix.px_get_row(self.px_snake_head)
        if not direction:
            snake_add_px(random.randint(1, 4))

        elif direction == "up":
            px = self.px_snake_head - self.matrix.dim_y

            if px < 0:
                px = self.px_snake_head + ((self.matrix.dim_x * self.matrix.dim_y) - self.matrix.dim_x)

        elif direction == "down":
            px = self.px_snake_head + self.matrix.dim_y

            if px > self.matrix.npxm - 1:
                px = self.matrix.px_get_column(self.px_snake_head) - 1

        elif direction == "left":
            if self.matrix.px_get_column(self.px_snake_head) == 1:
                px = self.px_snake_head + self.matrix.dim_x - 1
            else:
                px = self.px_snake_head - 1
            if px < 0:
                px = self.matrix.dim_x - 1

        elif direction == "right":
            if self.matrix.px_get_column(self.px_snake_head) == self.matrix.dim_x:
                px = self.px_snake_head - self.matrix.dim_x -1
            else:
                px = self.px_snake_head + 1
            if px > self.matrix.npxm:
                px = self.matrix.npxm - self.matrix.dim_x - 1

        if px in self.px_snake:
            self.game_over()

        if px not in self.px_food:
            self.px_snake.pop(0)

        self.px_snake.append(px)
        self.px_snake_head = px

    def set_food(self):
        is_occupied = True

        while is_occupied:

            npxm = random.randint(0, self.matrix.npxm)

            if npxm not in self.px_food:
                is_occupied = False

            if npxm not in self.px_snake:
                is_occupied = False

        self.px_food.append(npxm)

    def get_frame(self):
        frame = []

        for x in range(0, self.matrix.npxm):
            if x in self.px_snake:
                frame.append(self.c_fg)
            elif x in self.px_food:
                frame.append(self.c_food)
            else:
                frame.append(self.c_bg)

        return frame

    def game_over(self):
        self.matrix.set_colour("FF0000")
        log.info("Game Over")
        sys.exit()


class HandleSignals:

    def __init__(self):
        self.original_sigint = signal.getsignal(signal.SIGINT)
        signal.signal(signal.SIGINT, self.shutdown)

    def restore(self):
        signal.signal(signal.SIGINT, self.original_sigint)

    def shutdown(self):
        self.restore()
        log.info("Exiting")
        sys.exit(1)


class Service:

    def __init__(self, name, cmd_start, desc, env):
        self.name = name
        self.cmd_start = cmd_start
        self.desc = desc
        self.env_args = ""

        if not env:
            self.env_args = ""
        else:
            for k, v in env.items():
                self.env_args += "--setenv=" + k + "=" + str(v) + " "

    def get_state(self):
        cmd = "systemctl --user show -p SubState " + self.name
        p = self.run_cmd(cmd)
        r = "unknown"

        if p:
            if hasattr(p, 'stdout') and p.stdout is not None:
                r = p.stdout.strip('\n')

        if r == "Unit " + self.name + ".service could not be found.":
            return "not-found"

        # remove 'SubState=' from string
        if len(r) > 8 and r != "unknown":
            return r[9:]

        return r

    def check(self):
        service_state = self.get_state()

        if not service_state:
            log.info("Could not determine service state")
        else:
            log.info(self.name + " service state: " + service_state)

        if service_state == "not-found":
            self.start_transient()

        elif service_state == "exited":
            self.start_transient()

        elif service_state == "failed":
            self.reset_failed()
            self.restart()

        elif service_state == "dead":
            #self.reset_failed()
            #self.restart()
            self.start_transient()

        elif service_state == "running":
            if action == "stop":
                log.info("Stopping %s service", self.name)
                self.stop()
                sys.exit(0)

    def start_transient(self):
        self.start("transient")

    def start(self, service_type="transient"):
        log.info("Starting service %s with type: %s", self.name
                                                    , service_type)

        cmd = 'systemd-run --user \
                           --unit=' + self.name + ' \
                           --description="' + self.desc + '" \
                           --remain-after-exit \
                           --no-block \
                           --send-sighup ' \
                           + self.env_args \
                           + self.cmd_start

        # for readability
        cmd = ' '.join(cmd.split())

        p = self.run_cmd(cmd, True)
        if p.stdout.strip('\n') == "Failed to start transient service unit: Unit " + self.name + " already exists.":
            self.restart()

    def restart(self):
        log.info("Restarting service: %s", self.name)
        cmd = 'systemctl --user restart ' + self.name
        p = self.run_cmd(cmd)

        if p.stdout.strip('\n') == "Failed to restart " + self.name + " unit. " + self.name + ".service not found.":
            log.info("Restart failed. Trying to start %s", self.name)
            self.start()

    def stop(self):
        cmd = 'systemctl --user stop ' + self.name
        self.run_cmd(cmd)

    def reset_failed(self):
        cmd = 'systemctl --user reset-failed ' + self.name
        self.run_cmd(cmd)

    @staticmethod
    def run_cmd(cmd,
                shell=True,
                stdin=None,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                env=os.environ,
                check=False):

        log.debug("Executing: %s", cmd)

        try:
            p = subprocess.run(cmd,
                               stdin=stdin,
                               input=None,
                               stdout=stdout,
                               stderr=stderr,
                               shell=shell,
                               universal_newlines=universal_newlines,
                               env=env,
                               check=check)

        except:
            e = sys.exc_info()[0]
            log.debug(e)
            raise

        try:
            p

        except NameError:
            log.info('Could not execute: %s', cmd)
            return False

        return p


class Homekit():

    def __init__(self, ip, port):
        self.hk_server_ip = ip
        self.hk_server_port = port
        self.client = UDPClient(self.hk_server_ip, self.hk_server_port)

    def toggle(self, value):
        self.client.sendm("toggle")

    def homekit_add_accessory(self):
        try:
            httpd = AccessoryServer(os.path.expanduser('~/.config/homekit/lightbulb-0.json'))

            accessory = Accessory('test_light', 'homekit_python', 'Demoserver', '0001', '0.1')
            light_service = LightBulbService()
            light_service.set_on_set_callback(self.toggle)
            accessory.services.append(light_service)
            httpd.accessories.add_accessory(accessory)

            httpd.publish_device()
            log.info('Published HomeKit device')
            httpd.serve_forever()
        except KeyboardInterrupt:
            log.info('Unpublish HomeKit device')
            httpd.unpublish_device()


def show_help():

    print("\n  Usage:")
    print("")
    print("    ledctrl help                            - Show this dialog")
    print("    ledctrl turn-on                         - Turn on the lights")
    print("    ledctrl turn-off                        - Turn off the lights")
    print("    ledctrl set-colour                      - Set colour")
    print("    ledctrl fade-colours                    - Fade colours")
    print("    ledctrl show-text                       - Show text")
    print("    ledctrl play-snake                      - Start snake game")
    print("    ledctrl stop                            - Stop snake game")
    print("\n")


if __name__ == '__main__':

    log = logging.getLogger('ledctrl')
    log.propagate = False
    log.addHandler(journal.JournalHandler())
    logging.root.addHandler(journal.JournalHandler())
    journal.JournalHandler(SYSLOG_IDENTIFIER='ledctrl')

    parser = configargparse.ArgParser(description="")
    parser.add_argument('--address', dest='address',
                                     env_var='LEDCTRL_ADDRESS',
                                     help="The address ledctrl listens on",
                                     type=str,
                                     required=True)

    parser.add_argument('--port', dest='port',
                                  env_var='LEDCTRL_PORT',
                                  help="The port ledctrl listens on",
                                  type=int,
                                  required=True)

    parser.add_argument('--target-address', dest='target_address',
                                            env_var='LEDCTRL_TARGET_0_ADDRESS',
                                            help="The address the target device listens on",
                                            type=str,
                                            required=True)

    parser.add_argument('--target-port', dest='target_port',
                                         env_var='LEDCTRL_TARGET_0_PORT',
                                         help="The port the target device listens on",
                                         type=int,
                                         required=True)

    parser.add_argument('--target-dim-x', dest='target_dim_x',
                                          env_var='LEDCTRL_TARGET_0_DIM_X',
                                          help="The number of LEDs or Pixels in the x dimension",
                                          type=int,
                                          required=True)

    parser.add_argument('--target-dim-y', dest='target_dim_y',
                                          env_var='LEDCTRL_TARGET_0_DIM_Y',
                                          help="The number of LEDs or Pixels in the y dimension",
                                          type=int,
                                          required=True)

    parser.add_argument('--homekit', dest='homekit',
                                     env_var='LEDCTRL_HOMEKIT',
                                     help="Enable HomeKit integration",
                                     type=str,
                                     default=False)

    parser.add_argument('--debug', dest='DEBUG',
                                   env_var='LEDCTRL_DEBUG',
                                   help="Enable debug mode",
                                   type=str,
                                   default=False)

    # Positional args
    sp = parser.add_subparsers(dest='action_cmd')
    for action_cmd in ['help', 'start', 'stop', 'homekit',
                       'set-colour', 'set-random-colour',
                       'show-clock', 'show-rainbow', 'show-snake',
                       'show-text', 'turn-on', 'turn-off']:

        sp.add_parser(action_cmd)

    spp = sp.add_parser('set-colour')
    spp.add_argument('colour', type=str)
    spp.add_argument('pixel', type=int)
    spp.add_argument('offset', type=int)

    args = parser.parse_args()
    ledctrl_address = args.address
    ledctrl_port = args.port
    target_address = args.target_address
    target_port = args.target_port
    target_dim_x = args.target_dim_x
    target_dim_y = args.target_dim_y
    homekit = args.homekit
    DEBUG = args.DEBUG
    args = []

    service_env = {
        "LEDCTRL_ADDRESS":          ledctrl_address,
        "LEDCTRL_PORT":             ledctrl_port,
        "LEDCTRL_TARGET_0_ADDRESS": target_address,
        "LEDCTRL_TARGET_0_PORT":    target_port,
        "LEDCTRL_TARGET_0_DIM_X":   target_dim_x,
        "LEDCTRL_TARGET_0_DIM_Y":   target_dim_y,
    }

    if DEBUG:
        log.setLevel(logging.DEBUG)
        log.info("DEBUG is enabled")
    else:
        log.setLevel(logging.INFO)

    # Default payload: effect to execute
    PAYLOAD = "turn-on"

    action = ""
    cmd_msg = ""

    if len(sys.argv) > 1:
        action = sys.argv[1]

    if action == "help":
        show_help()
        sys.exit(0)

    service_ledctrl = Service("ledctrl",
                              os.path.realpath(__file__) + " start",
                              "ledctrl server",
                              service_env)
    service_ledctrl.check()

    if homekit:
        service_homekit = Service("ledctrl-homekit",
                                  os.path.realpath(__file__) + " homekit",
                                  "ledctrl homekit server",
                                  service_env)
        service_homekit.check()

    if action == "homekit":
        hk = Homekit(ledctrl_address, ledctrl_port)
        hk.homekit_add_accessory()

    if action == "start":
        server = Server("udp",
                        ledctrl_address,
                        ledctrl_port,
                        target_address,
                        target_port,
                        target_dim_x,
                        target_dim_y)

        server.matrix.exec_payload(PAYLOAD)

        while True:
            time.sleep(1)
            server.receive()

    if len(action) > 0:
        cmd_msg = action
        if len(sys.argv) > 3:
            cmd_msg = sys.argv[1] + " " + sys.argv[2] + " " + sys.argv[3]
        elif len(sys.argv) > 2:
            cmd_msg = sys.argv[1] + " " + sys.argv[2]
        elif len(sys.argv) > 1:
            cmd_msg = sys.argv[1]

    sys.argv = []

    if len(cmd_msg) > 0:
        log.debug("Sending: %s", cmd_msg)
        client = UDPClient(ledctrl_address, ledctrl_port)
        client.sendm(cmd_msg)
