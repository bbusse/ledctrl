#!/usr/bin/env python3
#
# ledctrl
#
# min python version: 3.5
#
# dependencies:
#  - python-systemd
#
# © 2016 Björn Busse (see also: LICENSE)
# bj.rn@baerlin.eu

import logging
import math
import os
import random
import socket
import subprocess
import signal
import struct
import sys
import termios
import time
from systemd import journal
from homekit import AccessoryServer
from homekit.model import Accessory, LightBulbService

#server_ip = "::1"
server_ip = "10.64.64.110"
server_port = 4223
server_proto = "udp"
#client_ip = "10.64.64.98"
client_ip = "10.64.64.71"
client_port = 2342
client_proto = "udp"
# number of pixels in the x dimension
dim_x = 8
# number of pixels in the y dimension
dim_y = 6
# default payload: effect to execute
payload = "set-colour"
# loglevel: info / warning / debug
loglevel = "debug"

f2c = lambda f: int(f * 255.0) & 0xff
c2f = lambda c: float(c) / 255.0
alpha = lambda c: (c >> 24) & 0xff
red = lambda c: (c >> 16) & 0xff
green = lambda c: (c >> 8) & 0xff
blue = lambda c: c & 0xff
pack = lambda a, r, g, b: (f2c(a) << 24) | (f2c(r) << 16) | (f2c(g) << 8) | f2c(b)


class Server():

    def __init__(self, server_proto, server_ip, server_port, client_ip, client_port, dim_x, dim_y):
        self.ip = server_ip
        self.port = server_port
        self.client_con = UDPClient(client_ip, client_port)
        self.server_proto = server_proto
        self.serve()

        sh = HandleSignals()
        self.prntr = Printer()

        self.matrix = Matrix(self.sock, dim_x, dim_y, self.client_con, self.prntr)
        self.matrix.reset()
        self.state = False

    def toggle_state(self):
        '''
        Toggle on/off state
        '''
        self.state = not self.state

    def get_toggle_state(self):
        return self.state

    def set_payload(self, payload):
        self.payload = payload

    def get_payload(self):
        return self.payload

    def serve(self):
        self.sock = socket.socket(socket.AF_INET,
                                  socket.SOCK_DGRAM)

        try:
            self.sock.bind((self.ip, self.port))
        except OSError as e:
            print("Failed to bind socket: ", self.ip, self.port, e)
            sys.exit(1)

        print("Serving on", self.ip, self.port)

    def receive(self):
        data = ""

        # non-blocking (0x40)
        try:
            data, (ip, port) = self.sock.recvfrom(1024, 0x40)
        except Exception as e:
            print("UDP receive: No data. Waiting for commands")
            pass

        if len(data) > 0:
            self.parse_msg(data)

    def get_port():
        return self.port

    def parse_msg(self, data):
        data = str(data).strip('b\'')
        msg = "Received message: " + data
        self.prntr.printi(msg)

        if data == "ping":
            self.prntr.printi("pong")
            return

        elif data == "get-payload":
            self.prntr.printi("Current payload: " + self.get_payload())
            return

        self.matrix.exec_payload(data)


class Matrix(server):

    reverse_even_row = False
    status = "Reverse Pixel Order"
    frame_prev = []

    _px_layout = [0, 1, 2, 3, 4,
                 9, 8, 7, 6, 5,
                 10, 11, 12, 13, 14,
                 19, 18, 17, 16, 15,
                 20, 21, 22, 23, 24]

    px_layout = [  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
                  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
                  20,  21,  22,  23 , 24,  25,  26,  27,  28,  29,
                  30,  31,  63,  62,  61,  60,  59,  58,  57,  56,
                  55,  54,  53,  52,  51,  50,  49,  48,  47 , 46,
                  45,  44,  43,  42,  41,  40,  39,  38,  37,  36,
                  35,  34,  33,  32,  64,  65,  66,  67,  68,  69,
                  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
                  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
                  90,  91,  92,  93,  94,  95, 127, 126, 125, 124,
                 123, 122, 121, 120, 119, 118, 117, 116, 115, 114,
                 113, 112, 111, 110, 109, 108, 107, 106, 105, 104,
                 103, 102, 101, 100,  99,  98,  97,  96, 128, 129,
                 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
                 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
                 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
                 191, 190, 189, 188, 187, 186, 185, 184, 183, 182,
                 181, 180, 179, 178, 177, 176, 175, 174, 173, 172,
                 171, 170, 169, 168, 167, 166, 165, 164, 163, 162,
                 161, 160, 192, 193, 194, 195, 196, 197, 198, 199,
                 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
                 210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
                 220, 221, 222, 223, 255, 254, 253, 252, 251, 250,
                 249, 248, 247, 246, 245, 244, 243, 242, 241, 240,
                 239, 238, 237, 236, 235, 234, 233, 232, 231, 230,
                 229, 228, 227, 226, 225, 224]

    def __init__(self, sock, dim_x, dim_y, con, prntr):
        self.con = con
        self.dim_x = dim_x
        self.dim_y = dim_y
        self.npxm = dim_x * dim_y
        self.prntr = prntr
        self.sock = sock
        self.state = False

    def get_payload(self):
        return self.state

    def exec_payload(self, data):
        args = data.split()
        print(*args, sep='\t')
        payload = args.pop(0)
        self.set_payload(payload)

        self.prntr.printi("Executing payload: " + payload)

        if payload == "turn-on":
            colour = "FF3399"
            self.set_colour(colour)

        elif payload == "turn-off":
            colour = "000000"
            self.set_colour(colour)

        elif payload == "toggle":
            state = self.get_toggle_state()
            self.prntr.printi("State: " + str(state))
            if not state:
                colour = "FF3399"
                self.toggle_state()
                self.set_colour(colour)
            else:
                colour = "000000"
                self.toggle_state()
                self.set_colour(colour)

        elif payload == "cycle":
            colour = "FF3399"
            colour_bg = "000000"
            self.cycle(colour, colour_bg, 0.1, 32)

        elif payload == "set-colour" or payload == "switch-colour":
            colour = "99FF66"
            if len(args) == 1:
                if len(args[0]) == 6:
                    colour = args[0]
                    self.set_colour(colour, "000000", True, 256)
            elif len(args) == 2:
                if len(args[0]) == 6:
                    colour = args[0]
                    pos = args[1]
                    self.prntr.printi("yo")
                    if pos > -1 and pos <= self.npxm:
                        self.set_px_colour(colour, pos, True)

        elif payload == "set-random-colour":
            self.set_random_colour()

        elif payload == "fade-colours":
            self.colour_fade()

        elif payload == "show-snake":
            self.show_rainbow_snake()

        elif payload == "show-rainbow":
            self.show_rainbow()

        elif payload == "set-random-pixel":
            self.set_random_pixel()

        elif payload == "show-text":
            self.show_text("ledctrl")

        elif payload == "show-image":
            self.show_image("e.bmp", "bitmap")

        elif payload == "show-clock":
            self.show_clock()

        elif payload == "play-snake":
            snake = SnakeGame(self.client_con, self.matrix)

        elif payload == "cycle-lines":
            colour = "FF3399"
            colour_bg = "000000"
            self.move_lines(colour, colour_bg, 0.08)

        else:
            self.prntr.printi("There is no such command or payload")
            show_help()
            return False

    def get_px_pos(self, px):
        return self.px_layout.index(px)

    def colour_gen_hex_code(self):
        return ''.join([random.choice('0123456789ABCDEF') for x in range(6)])

    def colour_hex_to_rgb(self, hex_str):
        if hex_str.startswith('#'):
            hex_str = hex[1:]
        if hex_str.__len__() == 3:
            hex_str = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]
        return tuple([int(hex_str[i:i + 2], 16) for i in range(0, len(hex_str), 2)])

    def colour_rgb_to_hex(self, rgb):
        return ''.join(["%0.2X" % c for c in rgb])

    def colour_hex_to_hls(self, c_hex):
        rgb = self.colour_hex_to_rgb(c_hex)
        return rgb_to_hls(rgb[0], rgb[1], rgb[2])

    def colour_fade(self, colours=[0xffFFF5C3, 0xff0BD7D5, 0xffFF7260], speed=1, steps=1000):
        self.prntr.printi("Running payload: " + payload + " with colours: at speed: " + str(speed))

        for x in range(colours.__len__()):
            if not type(colours[x]) is int:
                c = "0xff" + colours[x]
                colours[x] = int(c, 16)

        colours = self.colour_get_gradient(colours, steps)
        self.prntr.printi(str(colours.__len__()))

        while True:
            for x in range(colours.__len__()):
                self.set_colour(colours[x])
                self.prntr.printi("Current colour: " + colours[x])
                time.sleep(speed)

            # reverse list
            colours = colours[::-1]

    def colour_get_gradient(self, colours, steps):
        colours_per_step = steps / len(colours)
        gradient = []

        for x, colour in enumerate(colours):

            r1 = c2f(red(colour))
            g1 = c2f(green(colour))
            b1 = c2f(blue(colour))

            colour2 = colours[(x + 1) % len(colours)]

            r2 = c2f(red(colour2))
            g2 = c2f(green(colour2))
            b2 = c2f(blue(colour2))

            # Generate a gradient of one step from colour to colour:
            delta = 1.0 / colours_per_step
            for y in range(int(colours_per_step)):
                t = y * delta
                a = 1.0
                r = (1.0 - t) * r1 + t * r2
                g = (1.0 - t) * g1 + t * g2
                b = (1.0 - t) * b1 + t * b2

                c = '0x{0:x}'.format(pack(a, r, g, b))
                gradient.append(c[4:])

        return gradient

    def reset(self, colour="794044"):
        self.set_colour(colour)

    def set_colour(self, colour="FFFFFF", colour_bg="000000", npx=23, offset=0):
        frame = []
        n = 2
        rgb = self.colour_hex_to_rgb(colour)
        self.prntr.printi("\x1b[38;" + str(rgb[0]) +";"
                                     + str(rgb[1]) + ";"
                                     + str(rgb[2]) + ";249m"
                                     + colour + "\x1b[0m "
                                     + colour)

        if npx > 0:
            # Set selected pixels to colour
            for x in range(self.npxm):
                if  offset == x:
                    frame.append(colour)
                elif (x > offset) and (x < (offset + npx)):
                    frame.append(colour)
                else:
                    frame.append(colour_bg)
        else:
            # Set all pixels to colour
            for x in range(self.npxm):
                frame.append(colour)

        self.draw(frame)

    def set_random_colour(self, t_sleep=30):

        while True:
            c = self.colour_gen_hex_code()
            self.set_colour(c)
            time.sleep(t_sleep)

    def set_random_pixel(self, t_sleep=0.5):

        while True:
            frame = []

            self.prntr.printi("state: " + self.state + " payload: " + self.payload)
            if self.state != "switch":
                return

            for x in range(self.npxm):
                frame.append(self.colour_gen_hex_code())

            self.draw(frame)
            time.sleep(t_sleep)
            self.reset()

    def show_image(self, fn, type):
        img = Bitmap(fn, self.dim_x, self.dim_y)
        img_data = img.read_file(fn)
        img.print_header_data(fn)
        bmp_frame = img.read_pixel_array(fn)
        print(bmp_frame)
        return

    def cycle(self, colour, colour_bg, speed=0.1, npx=1):
        while True:
            for i in range(self.npxm):
                if self.state != payload:
                    return

                if npx > -1:
                    # Set npx pixels at once
                    self.set_colour(colour, colour_bg, False, npx, i)
                else:
                    # Set a single pixel
                    self.set_colour(colour, colour_bg, False, 1, 1)

                self.prntr.printi("state: " + self.state + " payload: " + self.payload)
                time.sleep(speed)

    def shift(self, list, n):
        for i in range(n):
            t = list.pop()
            list.insert(0, t)

        return list

    def show_rainbow(self, colours = ["ffa500",
                                      "ff4500",
                                      "8a2be2",
                                      "0000ff",
                                      "7fffd4",
                                      "228b22",
                                      "ffff00"],
                                      speed=0.1):

        ncolours = colours.__len__()

        while True:
            frame = []

            for y in range(self.dim_y):
                for x in range(self.dim_x):
                    frame.append(colours[y])

            self.draw(frame)
            colours = self.shift(colours, 1)
            time.sleep(speed)

    def show_rainbow_snake(self, colours = ["ffa500",
                                            "ff4500",
                                            "8a2be2",
                                            "0000ff",
                                            "7fffd4",
                                            "228b22",
                                            "ffff00"],
                                            c_bg="444444",
                                            speed=1):

        frame = []

        for x in range(colours.__len__()):
            frame.append(colours[x])

        if self.npxm > colours.__len__():
            for x in range(colours.__len__(), self.npxm):
                frame.append(c_bg)

        while True:
            self.reverse_even_row = False
            self.draw(frame)
            frame = self.shift(frame, 1)
            time.sleep(speed)

    def show_clock(self, c_h="ff0000", c_m="ff0000", c_bg="ffffff"):

        while True:
            frame = []
            t = time.strftime("%H:%M")
            t_h = int(time.strftime("%H"))
            t_m = time.strftime("%M")
            t_m1 = int(t_m[0:1])
            t_m2 = int(t_m[1:2])

            for x in range(0, self.npxm):
                if x < t_h:
                    frame.append(c_h)
                else:
                    frame.append(c_bg)

            self.draw(frame)
            time.sleep(3)
            frame = []

            for x in range(0, self.npxm):

                if x < 15 and x < t_m1:
                    frame.append(c_m)
                elif x > 14 and x < (t_m2 + 15):
                    frame.append(c_m)
                else:
                    frame.append(c_bg)

            self.draw(frame)
            time.sleep(5)

    # reverse_direction: Do not jump to line 1 but go backwards
    # on last line
    def move_lines(self, colour, colour_bg, speed, reverse_direction=True):
        '''
        Draw lines of variable length at some offset
        :param str colour: The colour of the line
        :param str colour_bg: The background colour
        :param float speed: The refresh rate
        :param bool reverse_direction: Reverse moving direction, defaults to True
        '''
        up = True

        while True:
            for i in range(1, self.dim_y + 1):

                # Move into one direction
                if up:
                    j = i
                    if i == 6 and reverse_direction:
                        up = not up
                # Reverse direction
                else:
                    j = self.dim_y - i
                    if j == 1:
                        i = 2
                        up = not up
                        break

                offset = (j * self.dim_x) - self.dim_x
                self.prntr.printi(str(j) + " " + str(self.dim_x) + " " + str(offset))
                self.set_colour(colour, colour_bg, self.dim_x, offset)
                time.sleep(speed)

    def px_get_row(self, n):
        return math.ceil((n + 1) / dim_y)

    def px_get_column(self, n):
        nrow = self.px_get_row(n)
        if nrow == 0:
            ncol = n - dim_x
        else:
            ncol = n - (dim_x * nrow) + dim_x + 1
        return ncol

    def scroll_text(self, text, speed=0.5, c_fg="ff0000", c_bg="ffffff", dir="left"):
        nframes = text.__len__() * self.npxm
        start = 0
        t=[]

        for y in range(text.__len__()):
            t.append(text[y])

        for x in range(0, nframes):
            frame = []

            if dir == "left":
                z = 0
                l = t.__len__() - 5
                for y in range(l):
                    if y == z:
                        z = z + 5
                        p = t.pop(y)
                        print("Popped", y)
                        if y >= self.npxm:
                            i = y - self.npxm
                            print("Inserting", i, p)
                            t.insert(i, p)

                for y in range(self.npxm):
                    if t[y] == "0":
                        c = c_bg
                    else:
                        c = c_fg
                    frame.append(c)

                self.draw(frame)


            if dir == "up":
                for y in range(self.npxm):
                    if text[start+y]:
                        c = c_bg
                    else:
                        c = c_fg

                    frame.append(c)

                start = start + self.dim_x

            self.draw(frame)
            time.sleep(speed)

    def show_text(self, s, scroll=True, loop=True, speed=1):
        t_sleep = speed
        text = ""

        if scroll:
            for x in range(s.__len__()):
                text += str(self.font_get_char(s[x]))
            self.scroll_text(text, speed)

        else:
            if loop:
                while True:
                    for x in range(s.__len__()):
                        self.font_show_char(s[x])
                        time.sleep(t_sleep)

            for x in range(s.__len__()):
                self.font_show_char(s[x])
                time.sleep(t_sleep)

    def font_get_char(self, c, font="f5x5"):
        f5x5 = {"A" : "0010001010011100101001010",
                "B" : "1111010001111101000111110",
                "C" : "0111110000100001000001111",
                "D" : "1111010001100011000111110",
                "E" : "1111110000111111000011111",
                "F" : "1111110000111001000010000",
                "G" : "0111110000101111000101111",
                "H" : "1000110001111111000110001",
                "I" : "0010000100001000010000100",
                "J" : "0011100001000011000101110",
                "K" : "1001010100111101000110001",
                "L" : "0100001000010000100001110",
                "N" : "1100110101101011010110011",
                "T" : "1111100100001000010000100",
                "i" : "0010000000001000010000100",
                "3" : "0111000001011100000101110",
                " " : "0000000000000000000000000",
                "<" : "0001000100010000010000010",
                ":" : "0000000100000000010000000"}

        return f5x5[c]

    def font_show_char(self, c, c_fg="FF0000", c_bg="FFFFFF"):
        frame = []
        p = self.font_get_char(c)

        for x in range(p.__len__()):
            px = p[x]

            if px == "0":
                px = c_bg
            else:
                px = c_fg

            frame.append(px)

        self.draw(frame)

    def draw(self, frame):
        msg_lst = []
        msg = ""

        if self.reverse_even_row:
            for x in range(0, self.npxm):
                msg += frame[self.px_layout.index(x)]
        else:
            for x in range(0, self.npxm):
                msg += frame[x]


        self.con.send(msg)
        super().receive()


class Bitmap():

    def __init__(self, fn, x, y):
        self.dim_x = x
        self.dim_y = y
        self.height = self.get_height(fn)
        self.width = self.get_width(fn)

    def colour_rgb_to_hex(self, rgb):
        return ''.join(["%0.2X" % c for c in rgb])

    def read_file(self, fn):
        file = open(fn, "rb")
        data = file.read()
        file.close()
        return data

    def get_header_size(self, fn):
        offset = 10
        fh = open(fn, 'rb')
        fh.seek(offset, 0)
        pixel_array_offset = struct.unpack('I', fh.read(4))
        return pixel_array_offset[0]

    def get_height(self, fn):
        offset = 10
        fh = open(fn, 'rb')
        fh.seek(offset, 0)
        width = struct.unpack('I', fh.read(4))
        return width[0]

    def get_width(self, fn):
        return 24

    def read_pixel_array(self, fn):
        fh = open(fn, "rb")

        # Skip the DIB header (12-124)
        header_size = self.get_header_size(fn)
        fh.seek(header_size, 0)

        # Pixels are stored starting at the bottom left
        frame = []
        rows = []
        row = []
        npx = 0

        while True:
            if npx == self.width:
                npx = 0
                rows.insert(0, row)
                if len(row) != self.width * 3:
                    raise Exception("Unsupported row length")
                row = []
            npx += 1

            r_str = fh.read(1)
            g_str = fh.read(1)
            b_str = fh.read(1)

            if len(r_str) == 0:
                # This is expected to happen when we've read everything.
                if len(rows) != self.dim_y:
                    print("Failed to parse pixel array of bitmap")
                break

            if len(g_str) == 0:
                print("Got 0 length string for green. Aborting")
                break

            if len(b_str) == 0:
                print("Got 0 length string for blue. Aborting")
                break

            r = ord(r_str)
            g = ord(g_str)
            b = ord(b_str)
            row.append(b)
            row.append(g)
            row.append(r)
            rgb = (r, g, b)

            frame.append(self.colour_rgb_to_hex(rgb))

        fh.close()
        return frame

    def print_header_data(self, fn):
        bmp = open(fn, 'rb')
        print('Type:', bmp.read(2).decode())
        print('Size: %s' % struct.unpack('I', bmp.read(4)))
        print('Reserved 1: %s' % struct.unpack('H', bmp.read(2)))
        print('Reserved 2: %s' % struct.unpack('H', bmp.read(2)))
        print('Offset: %s' % struct.unpack('I', bmp.read(4)))
        print('DIB Header Size: %s' % struct.unpack('I', bmp.read(4)))
        print('Width: %s' % struct.unpack('I', bmp.read(4)))
        print('Height: %s' % struct.unpack('I', bmp.read(4)))
        print('Colour Planes: %s' % struct.unpack('H', bmp.read(2)))
        print('Bits per Pixel: %s' % struct.unpack('H', bmp.read(2)))
        print('Compression Method: %s' % struct.unpack('I', bmp.read(4)))
        print('Raw Image Size: %s' % struct.unpack('I', bmp.read(4)))
        print('Horizontal Resolution: %s' % struct.unpack('I', bmp.read(4)))
        print('Vertical Resolution: %s' % struct.unpack('I', bmp.read(4)))
        print('Number of Colours: %s' % struct.unpack('I', bmp.read(4)))
        print('Important Colours: %s' % struct.unpack('I', bmp.read(4)))


class Printer():

    buf = ""

    def __init__(self, loglevel="info", use_journal=True):
        self.use_journal = use_journal
        self.loglevel = loglevel

    def init_canvas(dim_x, dim_y):
        self.dim_x = dim_x
        self.dim_y = dim_y

    def print(self, msg):
        print(msg)

        if self.use_journal:
            journal.send(msg)

    # info
    def printi(self, msg):
        if self.loglevel == "info" or self.loglevel == "warning" or self.loglevel == "debug":
            self.print(msg)

    # warning
    def printw(self, msg):
        if self.loglevel == "warning" or self.loglevel == "debug":
            self.print(msg)

    # debug
    def printd(self, msg):
        if self.loglevel == "debug":
            self.print(msg)

    # exception
    def printe(self, msg):
        print(msg)

    def term_draw(self, msg):
        start = 0
        end = 6
        len = msg.__len__()
        ntoks = int(len / 6)

        self.term_clear()

        for x in range(self.dim_y):

            if x > 0:
                start = start + (self.dim_x * 6)
                end = end + (self.dim_x * 6)

            print(msg[start:end],
                  msg[start+6:end+6],
                  msg[start+12:end+12],
                  msg[start+18:end+18],
                  msg[start+24:end+24])

        print("")
        print(self.buf)
        self.buf = ""

    def term_print(self, msg):
        self.buf += msg

    def term_clear(self):
        print(chr(27) + "[2J")


class UDPClient():

    def __init__(self, ip, port):
        self.ip = ip
        self.port = port
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        #self.sock.setsockopt(socket.IPPROTO_IP, IN.IP_MTU_DISCOVER, IN.IP_PMTUDISC_WANT)
        self.sock.setsockopt(socket.IPPROTO_IP, socket.SO_REUSEADDR, 1)
        #self.sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_V6ONLY, 0)
        self.prntr = Printer()

    def send(self, m):
        try:
            self.sock.sendto(bytes.fromhex(m), (self.ip, self.port))
        except Exception as e:
            self.prntr.printi(str(e))
            self.prntr.printi("Network unavailable. Aborting")
            sys.exit(1)

    def sendm(self, m):
        try:
            self.sock.sendto(bytes(m, "UTF-8"), (self.ip, self.port))
        except:
            self.prntr.printi("Network unavailable. Aborting")
            sys.exit(1)


class KeyInput():

    old_settings = None

    def __init__(self):
        self.ch_set = []
        self.old_settings = termios.tcgetattr(sys.stdin)

        new_settings = termios.tcgetattr(sys.stdin)
        new_settings[3] = new_settings[3] & ~(termios.ECHO | termios.ICANON)
        new_settings[6][termios.VMIN] = 0
        new_settings[6][termios.VTIME] = 0
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, new_settings)

    def get_key(self):
        self.ch = os.read(sys.stdin.fileno(), 3)

        if self.ch is not None and len(self.ch) > 0:
            self.ch_set.append(self.ch)

        return self.ch

    def get_key_parsed(self):
        self.ch = self.get_key()

        if self.ch  == bytes('\x1b[A', "utf-8"):
            return "up"
        elif self.ch == bytes('\x1b[B', "utf-8"):
            return "down"
        elif self.ch == bytes('\x1b[C', "utf-8"):
            return "right"
        elif self.ch == bytes('\x1b[D', "utf-8"):
            return "left"

    #@atexit.register
    def exit(self):
        if self.old_settings:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)


class SnakeGame():

    px_snake = []
    px_food = []
    px_snake_head = 0
    frame = []
    frame_prev = []

    def __init__(self, con, matrix, c_fg="ff0000", c_food="0000ff", c_bg="ffffff"):
        self.con = con
        self.matrix = matrix
        npxm = self.set_start_px()
        self.c_fg = c_fg
        self.c_bg = c_bg
        self.c_food = c_food
        self.kb = KeyInput()
        self.matrix.draw(self.get_frame())
        dirs = ["up", "down", "left", "right"]
        direction = random.choice(dirs)
        self.start_game(direction)

    def start_game(self, direction):

        cycles = 0

        while True:

            key = self.kb.get_key_parsed()

            if key is not None and len(key) > 0:

                if key  == 'up':
                    direction = "up"
                elif key == 'down':
                    direction = "down"
                elif key == 'right':
                    direction = "right"
                elif key == 'left':
                    direction = "left"

            time.sleep(0.1)
            cycles = cycles + 1

            if cycles > 10:

                self.move(direction)
                self.matrix.draw(self.get_frame())

                if not self.px_food:
                    self.set_food()

                cycles = 0


    def set_start_px(self):
        px = random.randint(0, self.matrix.npxm - 1)
        self.px_snake.append(px)
        self.px_snake_head = px
        return px

    def move(self, dir):
        px = 0
        ncol = self.matrix.px_get_column(self.px_snake_head)
        nrow = self.matrix.px_get_row(self.px_snake_head)
        if not dir:
            snake_add_px(random.randint())

        elif dir == "up":
            px = self.px_snake_head - dim_y

            if px < 0:
                px = self.px_snake_head + ((dim_x * dim_y) - dim_x)

        elif dir == "down":
            px = self.px_snake_head + dim_y

            if px > self.matrix.npxm - 1:
                px = self.matrix.px_get_column(self.px_snake_head) - 1

        elif dir == "left":
            if self.matrix.px_get_column(self.px_snake_head) == 1:
                px = self.px_snake_head + dim_x - 1
            else:
                px = self.px_snake_head - 1
            if px < 0:
                px = dim_x - 1

        elif dir == "right":
            if self.matrix.px_get_column(self.px_snake_head) == dim_x:
                px = self.px_snake_head - dim_x -1
            else:
                px = self.px_snake_head + 1
            if px > self.matrix.npxm:
                px = self.matrix.npxm - dim_x - 1

        if px in self.px_snake:
            self.game_over()

        if px not in self.px_food:
            self.px_snake.pop(0)

        self.px_snake.append(px)
        self.px_snake_head = px

    def set_food(self):
        is_occupied = True

        while is_occupied:

            npxm = random.randint(0, self.matrix.npxm)

            if npxm not in self.px_food:
                is_occupied = False

            if npxm not in self.px_snake:
                is_occupied = False

        self.px_food.append(npxm)

    def get_frame(self):
        frame = []

        for x in range(0, self.matrix.npxm):
            if x in self.px_snake:
                frame.append(self.c_fg)
            elif x in self.px_food:
                frame.append(self.c_food)
            else:
                frame.append(self.c_bg)

        return frame

    def game_over(self):
        self.matrix.set_colour("FF0000")
        print("Game Over")
        sys.exit()


class HandleSignals:

    def __init__(self):
        self.original_sigint = signal.getsignal(signal.SIGINT)
        signal.signal(signal.SIGINT, self.shutdown)
        self.prntr = Printer()

    def restore(self):
        signal.signal(signal.SIGINT, self.original_sigint)

    def shutdown(self):
        self.restore()
        self.prntr.printi("Exiting")
        sys.exit(1)


class Service:

    def __init__(self, name, cmd_start, desc, loglevel="debug"):
        self.name = name
        self.cmd_start = cmd_start
        self.desc = desc
        self.prntr = Printer(loglevel)

    def get_state(self):
        cmd = "systemctl --user show -p SubState " + self.name
        p = self.run_cmd(cmd)
        r = "unknown"

        if p:
            if hasattr(p, 'stdout') and p.stdout is not None:
                r = p.stdout.strip('\n')

        if r == "Unit " + self.name + ".service could not be found.":
            return "not-found"

        # remove 'SubState=' from string
        if len(r) > 8 and r != "unknown":
            return r[9:]

        return r

    def check(self):
        service_state = self.get_state()

        if not service_state:
            prntr.printi("Could not determine service state")
        else:
            prntr.printi(self.name + " service state: " + service_state)

        if service_state == "not-found":
            self.start_transient()

        elif service_state == "exited":
            self.start_transient()

        elif service_state == "failed":
            self.reset_failed()
            self.restart()

        elif service_state == "dead":
            #self.reset_failed()
            #self.restart()
            self.start_transient()
            self.start_transient()

        elif service_state == "running":
            prntr.printi("Service is running")

            if action == "stop":
                prntr.printi("Stopping " + self.name + " service")
                self.stop()
                sys.exit(0)

    def start_transient(self):
        self.start("transient")

    def start(self, type="transient"):
        prntr.printi("Starting service: " + self.name)
        cmd = 'systemd-run --user \
                           --unit=' + self.name + ' \
                           --description="' + self.desc + '" \
                           --remain-after-exit \
                           --no-block \
                           --send-sighup ' + self.cmd_start

        # for readability
        cmd = ' '.join(cmd.split())

        p = self.run_cmd(cmd, shell=False, stdout=False, stderr=False)
        if p.stdout.strip('\n') == "Failed to start transient service unit: Unit " + self.name + " already exists.":
            self.restart()

    def restart(self):
        prntr.printi("Restarting service: " + self.name)
        cmd = 'systemctl --user restart ' + self.name
        p = self.run_cmd(cmd)

        if p.stdout.strip('\n') == "Failed to restart " + self.name + " unit. " + self.name + ".service not found.":
            self.prntr.printi("Restart failed. Trying to start "+ self.name)
            self.start()

    def stop(self):
        cmd = 'systemctl --user stop ' + self.name
        self.run_cmd(cmd)

    def reset_failed(self):
        cmd = 'systemctl --user reset-failed ' + self.name
        self.run_cmd(cmd)

    def run_cmd(self, cmd,
                      shell=True,
                      stdout=subprocess.PIPE,
                      stderr=subprocess.STDOUT,
                      universal_newlines=True):

        self.prntr.printd("Executing: " + cmd)

        try:
            p = subprocess.run(cmd,
                               stdin=None,
                               input=None,
                               stdout=subprocess.PIPE,
                               stderr=subprocess.STDOUT,
                               shell=True,
                               universal_newlines=True)

        except:
            e = sys.exc_info()[0]
            print(e)
            raise

        try:
            p

        except NameError:
            self.prntr.printi('Could not execute: ' + cmd)
            return False

        return p


class Homekit():

    def toggle(self, value):
        c = UDPClient(server_ip, server_port)
        c.sendm("toggle")

    def homekit_add_accessory(self):
        try:
            httpd = AccessoryServer(os.path.expanduser('~/.config/homekit/lightbulb-0.json'))

            accessory = Accessory('test_light', 'homekit_python', 'Demoserver', '0001', '0.1')
            lightService = LightBulbService()
            lightService.set_on_set_callback(self.toggle)
            accessory.services.append(lightService)
            httpd.accessories.add_accessory(accessory)

            httpd.publish_device()
            print('Published HomeKit device')
            httpd.serve_forever()
        except KeyboardInterrupt:
            print('Unpublish HomeKit device')
            httpd.unpublish_device()


def show_help():
    print("\n  Usage:")
    print("")
    print("    ledctrl help                            - show this dialog")
    print("    ledctrl turn-on                         - turn on the lights")
    print("    ledctrl turn-off                        - turn off the lights")
    print("    ledctrl set-colour                      - set colour")
    print("    ledctrl fade-colours                    - fade colours")
    print("    ledctrl show-text                       - show text")
    print("    ledctrl play-snake                      - start snake game")
    print("    ledctrl stop                            - stop snake game")
    print("\n")


if __name__ == '__main__':

    log = logging.getLogger('ledctrl')
    log.propagate = False
    #log.addHandler(JournalHandler())
    #logging.root.addHandler(JournalHandler())
    #log.setLevel(logging.DEBUG)
    #JournalHandler(SYSLOG_IDENTIFIER='ledctrl')
    #log.warning("Some message: %s", 'detail')

    prntr = Printer(loglevel)
    cmd = sys.argv[0]
    action = ""
    msg = ""
    payload_arg_0 = ""

    if sys.argv.__len__() > 1:
        if len(sys.argv[1]) > 0:
            action = sys.argv[1]
        if sys.argv.__len__() > 2:
            if len(sys.argv[2]) > 0:
                payload_arg_0 = sys.argv[2]
                if sys.argv.__len__() > 3:
                    if len(sys.argv[3]) > 0:
                        payload_arg_1 = sys.argv[3]

    sys.argv = []

    service_name = "ledctrl"
    cmd_start = "/usr/local/src/ledctrl/ledctrl start"
    service_ledctrl = Service(service_name, cmd_start, "ledctrl server")
    service_ledctrl.check()

    service_name_homekit = "ledctrl-homekit"
    cmd_start_homekit = "/usr/local/src/ledctrl/ledctrl homekit"
    service_homekit = Service(service_name_homekit, cmd_start_homekit, "ledctrl homekit server")
    service_homekit.check()

    if action == "help":
        show_help()
        sys.exit(0)

    if action == "homekit":
        hk = Homekit()
        hk.homekit_add_accessory()

    if action == "start":
        server = Server(server_proto,
                        server_ip,
                        server_port,
                        client_ip,
                        client_port,
                        dim_x,
                        dim_y)

        server.matrix.exec_payload(payload)

        while True:
            time.sleep(1)
            server.receive()

    if len(action) > 0:
        msg = action
        if len(payload_arg_0) > 0:
            msg = action + " " + payload_arg_0

    if len(msg) > 0:
        prntr.printd("Sending: " + msg)
        c = UDPClient(server_ip, server_port)
        c.sendm(msg)
